{
  "name": "bnd-dsap-plugin",
  "tagline": "Bnd Declarative Services Annotation Properties Plugin",
  "body": "# Bnd Declarative Services Annotation Properties Plugin\r\nThis plugin allows the definition of DS component properties using annotations\r\n\r\n## Available on Maven Central!\r\n\r\nInstead of a clumsy and error-prone property definition such as this:\r\n```java\r\n@Component(property = { \"custom.secure:Boolean=true\", \"custom.public:Boolean=true\",\r\n        \"custom.continent=AFRICA\", \"custom.continent=EUROPE\", \"service.ranking:Integer=10\",\r\n        \"custom.alias=yeepee\" })\r\npublic final class MyNotSoCoolComponent implements MyService {\r\n    // methods\r\n}\r\n```\r\n\r\nthis plugin will enrich the XML component descriptor at compile time so you can use annotations instead:\r\n\r\n```java\r\n@Secure(true)\r\n@Public\r\n@ContinentSpecific({Continent.AFRICA, Continent.EUROPE})\r\n@Component\r\n@ServiceRanking(10)\r\n@Alias(\"yeepee\")\r\npublic final class MyCoolComponent implements MyService {\r\n\r\n}\r\n```\r\n\r\nIt's only a matter of defining the annotations you like and annotating them with `@ComponentProperty(<propertyName>)`\r\n\r\n```java\r\n@ComponentProperty(\"custom.alias\")\r\n@Target(ElementType.TYPE)\r\npublic @interface Alias {\r\n    String value();\r\n}\r\n```\r\n\r\nThis generates the following XML descriptor:\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<component name=\"io.lambdacube.component.demo.basic.MyCoolComponent\">\r\n  <implementation class=\"io.lambdacube.component.demo.basic.MyCoolComponent\"/>\r\n  <service>\r\n    <provide interface=\"io.lambdacube.component.demo.basic.MyService\"/>\r\n  </service>\r\n  <property name=\"custom.secure\" type=\"Boolean\" value=\"true\"/>\r\n  <property name=\"custom.public\" type=\"Boolean\" value=\"true\"/>\r\n  <property name=\"custom.continent\" type=\"String\">AFRICA\r\nEUROPE</property>\r\n  <property name=\"service.ranking\" type=\"Integer\" value=\"10\"/>\r\n</component>\r\n\r\n```\r\n\r\n# `@ComponentPropertyGroup`\r\n\r\nIt is also possible to define an annotation that will potentially publish several properties using the annotation ```@ComponentPropertyGroup```.\r\n\r\n```java\r\n@ComponentPropertyGroup\r\n@Target(ElementType.TYPE)\r\npublic @interface GogoCommand {\r\n\r\n    @ComponentProperty(\"osgi.command.scope\")\r\n    String scope();\r\n\r\n    @ComponentProperty(\"osgi.command.function\")\r\n    String[]commandFunction();\r\n}\r\n```\r\n\r\nIn this case, both properties are added.\r\n\r\n\r\n# Caveats\r\n\r\nI am using Maven and maven-bundle-plugin because I am comfortable with it. Because there still isn't a release using bndlib 3.1.0, it is using 3.0.0. It's only a matter of changing the property `${bnd.version}` in the root POM to change bndlib's version, but the build will have to be adapted further until m-b-p's 3.1.0 release. \r\n\r\nAlso, Bnd does not support extending DS component descriptors properly. This is only a dirty hack, and it's not pretty. It doesn't matter because this is build-time code and it works fine, but it would be much cleaner if Bnd had first-class support for extensions in its DS component generator mechanism.\r\n\r\nFinally, defining the same property multiple times either through annotations or using the official `@Component(property={...})` syntax will result in the property being present several time in the XML and is likely to cause runtime problems :-).\r\n\r\ntl;dr: it works fine, and hopefully some day it can be rewritten in a cleaner way.  \r\n\r\n\r\n# Enabling the plugin\r\n\r\n\r\nWith Bnd:\r\n(The plugin has to be on the classpath).\r\n\r\n```\r\n-plugin: io.lambdacube.bnd.component.annotation.properties.DSAPPlugin\r\n```\r\n\r\nWith maven-bundle-plugin:\r\n```xml\r\n  <plugin>\r\n        <groupId>org.apache.felix</groupId>\r\n        <artifactId>maven-bundle-plugin</artifactId>\r\n        <extensions>true</extensions>\r\n        <version>3.0.0</version>\r\n        <configuration>\r\n          <instructions>\r\n            <_plugin>\r\n              io.lambdacube.bnd.component.annotation.properties.DSAPPlugin\r\n            </_plugin>\r\n          </instructions>\r\n        </configuration>\r\n        <dependencies>\r\n          <dependency>\r\n            <groupId>io.lambdacube.bnd</groupId>\r\n            <artifactId>bnd-dsap-plugin</artifactId>\r\n            <version>1.0-SNAPSHOT</version>\r\n          </dependency>\r\n        </dependencies>\r\n      </plugin>\r\n```\r\n\r\n# Usage for `@ComponentProperty` on the annotation type\r\n\r\n* `@ComponentProperty` annotations must either:\r\n  * be empty, in that case they are `Boolean` and the value is `Boolean.TRUE`.\r\n  * have exactly one method, named `value`\r\n    * default values are not supported (and not really useful), except for empty arrays (in that case, the property is ignored)\r\n    * if the return type is either `int`, `float`, `double`, `boolean`, the corresponding boxed type is used.\r\n    * otherwise, for Strings, Enums, Classes (or Annotations themselves, discouraged), the type is String and the value is the result of a call to `Object::toString` on the annotation value.  \r\n    * arrays are supported, and behave as you'd expect.\r\n* You are free to use a `RUNTIME` retention if you want to also introspect the annotations at runtime, but a `SOURCE` retention will not work (as Bnd works on classes).\r\n \r\n \r\n# Usage for `@ComponentPropertyGroup` on the annotation type\r\n\r\nThen you put `@ComponentProperty` on your annotation methods. The annotation must not be empty, and at least one method has to be annotated with `ComponentProperty`. Rules for methods are the same as above.\r\n \r\n \r\n# Advanced Usage\r\n\r\nIt is also possible to make annotations \"provide\" OSGi services. \r\n\r\nTake the following component:\r\n```java\r\n@Component(service = Object.class)\r\n@GogoCommand(scope = \"greeting\", commandFunction = { \"sayHello\", \"sayGoodbye\"})\r\npublic final class MyComponentWithShellCommands {\r\n\r\n    public void sayHello() {\r\n    }\r\n\r\n    public void sayGoodbye() {\r\n    }\r\n}\r\n\r\n```\r\n\r\nIn the `@Component` annotation, we have to specify `(service = Object.class)` because of the expectations of the consuming framework (e.g Gogo shell), which is filtering on service properties but doesn't care about the service interface itself (`objectClass` property) because it uses reflection.\r\n\r\nBecause of Declarative Services' rules, if a component does not provide a service either through implementing interfaces or explicitly providing them using the `(service = ...)` definition, then no service is published to the registry. I am not sure how much sense it makes to have component properties on such a service, but that is how things are currently :-). \r\n\r\nIf our component was providing any other service, it would not need to provide `Object.class` as well. This is just a trick to make sure it is registered as a service.\r\n\r\nThis plugin makes it possible, in these cases, to fallback to a `Object.class` without having to specify it. \r\n\r\n```java\r\n@EnsureProvideService\r\n@ComponentPropertyGroup\r\n@Target(ElementType.TYPE)\r\npublic @interface GogoCommand {\r\n\r\n    @ComponentProperty(\"osgi.command.scope\")\r\n    String scope();\r\n\r\n    @ComponentProperty(\"osgi.command.function\")\r\n    String[]commandFunction();\r\n}\r\n```\r\n\r\nThis feature is entirely optional, and it changes the semantic of DS slightly (for the better). Don't use `@EnsureProvideService` on your property annotations if you don't like it.\r\n\r\n\r\n \r\n# Updated Gogo example\r\n\r\n```java\r\n@Component\r\n@GogoCommand(scope = \"greeting\", commandFunction = { \"sayHello\", \"sayGoodbye\"})\r\npublic final class MyComponentWithShellCommands {\r\n\r\n    public void sayHello() {\r\n    }\r\n\r\n    public void sayGoodbye() {\r\n    }\r\n\r\n}\r\n```\r\n\r\nThe following XML gets generated:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<component name=\"io.lambdacube.component.demo.gogo.MyComponentWithShellCommands\">\r\n  <implementation class=\"io.lambdacube.component.demo.gogo.MyComponentWithShellCommands\"/>\r\n  <property name=\"osgi.command.scope\" type=\"String\" value=\"greeting\"/>\r\n  <property name=\"osgi.command.function\" type=\"String\">sayHello\r\nsayGoodbye</property>\r\n  <service>\r\n    <provide interface=\"java.lang.Object\"/>\r\n  </service>\r\n</component>\r\n```\r\n\r\n\r\nYou can find the code in the `examples` sub-module.\r\n\r\n\r\n# What's next\r\n\r\nI am interested in using annotations on @Reference methods.\r\n\r\n```java\r\n@Component\r\npublic final class IAmGogo {\r\n\r\n    @Reference(cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC)\r\n    public void addCommand(@CommandScope(\"*\") Object command) {\r\n\r\n    }\r\n\r\n    public void removeCommand(@CommandScope(\"*\") Object command) {\r\n\r\n    }\r\n}\r\n```\r\n\r\nthat would be equivalent to:\r\n\r\n```java\r\n@Component\r\npublic final class IAmGogo {\r\n\r\n    @Reference(target = \"(osgi.command.scope=*)\", cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC)\r\n    public void addCommand(Object command) {\r\n\r\n    }\r\n\r\n    public void removeCommand(Object command) {\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n# License\r\n\r\nApache Software License, version 2.0\r\n\r\n(c) Simon Chemouil, Lambdacube\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}